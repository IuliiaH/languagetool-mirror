"""

                                                          www.ScriptFoundry.com
                                               (212) 228 0093
                                                 development@scriptfoundry.com
 snakespell.py 1.01
      A basic spelling module, original written for a
      web based e-mail client, but can be used for
      any spelling necessity.

         o class SpellingChecker abstract class that
           implements the basic model.
         o class SpellingMistake abstract class
         o class Spell a subclass of SpellingChecker
           that implements the basic spell found on
           most unix systems.
         o class iSpell a subclass of SpellingChecker
           implements the basic ispell now pretty
           much standard on Linux. This offers a lot
           of options and functionality.
         o class aSpell coming real soon.
         o pspell If only I had known... I will be
           doing a pspell wrapper soon.
         o Download (latest) tgz, zip or rpm and then
           install

 class SpellingChecker
      This abstract class that implements the basic
      model.
        1. A spelling checker can be instantiated
           with a set of command line options,
           e.g.. '-a -s -d /dictionaries/mydict.ddt'.
           Implementations of this class can overload
           the processOptions method. This method
           takes a string and returns a string
           weeding out illegal options, and inserting
           the nececary ones to use the spelling
           checker as a filter.
        2. The spelling checker offers the following
           member methods:
              + check(self, text) that will pipe the
                text through the spelling checker. It
                creates an ordered dictionary of
                SpellingMistakes and then returns the
                number of mistakes.
              + getMistakes() returns the ordered
                dictionary of SpellingMistake. This
                dictionary can be treated as a list
                of the mistakes in the order in which
                they were found, or as a dictionary
                keyed by the mistake.
              + In situations where the text is very
                large, it is best to use the start,
                feed, result combination.
                   + call start()
                   + then repeatedly call feed(text),
                     to feed the text to the spell
                     checker.
                   + finally call result() the
                     generate the SpellingMistake
                     list and return the number of
                     mistakes.



      A spelling checker must overload and
      implement the following member methods:

         * pipeString(self, options): This
           method should create, with the
           options, and return the string to be
           fed to popen2. for instance it could
           be simplistically something like:
           def pipeString(self, options): return
           '/usr/bin/mySpeller %s' % options
         * processLine(self, line): This method
           invoked for each line generated by
           the spelling checker. It should
           process this line and then return
           SpellingMistake instatiated with the
           relevant values.
           for example with the simpler
           Speller.processLine(line):
           return SpellingMistake(line)
           or with the more complex
           iSpeller.processLine(line):
           return iSpellingMistake(original,
           types[kind], offset, corrections)

      A spelling checker could overload and
      implement the following member method:
      processOptions( options ) This is
      discussed above.

 class SpellingMistake
         o SpellingMistake object is instatiate with
           three arguments (word, type='',
           position=-1, correctionList=[]), where
           word is the word in error, type is the
           type of error, position is a long offset
           of this mistake from the beginning of the
           text,and correction list is a list of
           possible corrections.
         o getCorrections() returns a list of
           possible corrections.
         o getPositions() returns a list of long
           offsets where the mistake is found in the
           text.
         o getMistake() returns the word in error.
         o getType() returns the spell check result.
         o appendPosition(offset) adds an a mistake
           offset.

 class iSpell
      Usage:

      from scriptfoundry.snakespell import iSpell
      ispell = iSpell()
      ispell.check('frgy refries are the only kina of chios that we kina like')
      for mistake in ispell.getMistakes():
         print mistake

 class Spell

       Usage:
      from scriptfoundry.snakespell import Spell
      spell = Spell()
      spell.check('frgy refries are the only kina of chios that we kina like')
      print ispell.getMistakes()[:]





 Installing

 tar xvzf snakespell1.01.tar.gz

 cd snakespell1.01

 python setup.py install

 or

 rpm -iv snakespell1.01.noarch.rpm

 then check it out by doing

 $python
 >> from snakespell import Spell
 >>spell = Spell()
 >>ispell.check('frgy refries are the only kina of chios that we kina like')
 >>ispell.getMistakes()[:]

"""

__version__ = "1.01"



from string import split, join, strip
from getopt import getopt
from orderdict import OrderDict
from popen2 import popen2

class SpellingMistake:
	def __init__(self, word):
		self.word = word
	def __repr__(self):
		return self.word



class SpellingChecker:
	def __init__(self, optionsString=""):
		self.setOptions(optionsString)
		self.mistakeList=OrderDict()

	def setOptions(self, options):
		self.options = self.processOptions(options)

	def getOptions(self):
		return self.options

	def pipeString(self, options):
		pass
		

	def start(self, options = None):
		if options:
			self.option = options
		self.input, self.output  =  popen2(self.pipeString(self.options))


	def feed(self, text):
		self.output.write(text)

	def result(self):
		retval = None
		try:
			self.output.close()
			result =  split(self.input.read(), '\n')
			result = filter(len, result)
			for line in result[1:]:
				mistake = self.processLine(line)
				if mistake:
					if self.mistakeList.has_key(mistake.word):
						self.mistakeList[mistake.word].positions.extend(mistake.positions)
					else:
						self.mistakeList.append(mistake.word, mistake)
		except:
			import traceback
			traceback.print_exc()

		return len(self.mistakeList)
			

	def check(self, text, options=None):
		self.start(options)
		self.feed(text)
		return self.result()

	def getMistakes(self):
		return self.mistakeList


	def parserLine(self, line):
		return None

	def processOptions(self, options):
		return options

		
	def correction(self, word, correction, text, position=-1):
		pass
			


class iSpellingMistake(SpellingMistake):
	def __init__(self, word, kind, position, corrections=[]):
		SpellingMistake.__init__(self, word)
		self.kind = kind
		self.positions = [position,]
		self.corrections= corrections

	def getWord(self):
		return self.word

	def getPositions(self):
		return self.positions

	def appendPosition(self, position):
		self.positions.append(position)

	def getCorrections(self):
		return self.corrections
	def __repr__(self):
		return '%s, %s %s: %s' % ( self.kind, self.word, self.positions, self.corrections) 

	
class iSpell(SpellingChecker):
	def processOptions(self, newOptions):
		opts = split(newOptions)
		if '-a' not in opts:
			opts.append('-a')
		if '-m' not in opts:
			opts.append('-m')
		getopt(opts, 'tnBCPmSd:p:wW:la')
		return join(opts)


	def pipeString(self, options):
		return '/usr/bin/ispell %s' % options
	
	def processLine(self, line):
		types={'*':'OK', '+':'Root', '-':'Compound', '&':'Miss', '?':'Guess', '#':'None'}
		kind = line[0]
		if kind in  ('&', '?'):  # miss or guess
			head, missesNguesses = split(line[1:],':')
			original, count, offset = split(head)
			corrections = map(strip, split(missesNguesses,','))
		elif kind == '#': # None
			original, offset = split(line[1:])
			corrections =[]
		elif kind == '+': # Root
			original=line[1:]
			return
		elif kind =='-': # compound
			return
		else:
			return
		return iSpellingMistake(original, types[kind], long(offset), corrections)

			
class Spell(SpellingChecker):
	def pipeString(self, options):
		return '/usr/bin/spell %s' % options
	
	def processLine(self, line):
		return SpellingMistake(line)



if __name__ == '__main__':
	import sys
	print sys.argv
	ispell = iSpell('-a -m ')
	print '         1         2         3         4         5         6     '
	print '12345678901234567890123456789012345678901234567890123456789012345'
	text =  'covocov frgy refries are the only kina of chios that we kina like'
	ispell.check( text )
	print ispell.getMistakes()
	for mistake in ispell.getMistakes():
		print mistake
	spell = Spell()
	spell.check( text )
	print ispell.getMistakes()[:]
		
